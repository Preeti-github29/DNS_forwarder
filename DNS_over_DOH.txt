import logging
from scapy.all import DNS, DNSQR, DNSRR
import requests
from dnslib import DNSRecord, DNSHeader, DNSQuestion, RR
import base64
import warnings
import dns.resolver
import socket
import argparse
import os

# to ignore the warning generated by some module.
warnings.filterwarnings("ignore")

PORT = 53
qtype_map = {1: "A", 28: "AAAA", 15: "MX", 2: "NS", 5: 'CNAME'}


# method to initialize and write logger in logger file
def get_logger(filename):
    try:
        Log_Format = "%(message)s" # to define the format of the messages that we will get
        logging.basicConfig(filename=filename, filemode='a', format=Log_Format, level=logging.INFO)
        mainlogger = logging.getLogger()
    except:
        print("### Error in logger ###")
    #print ("first return value",mainlogger)
    return mainlogger

def create_server():
    # using try and catch to identify point of error
    try:
        SERVER_IP = socket.gethostname() + '.cs.uga.edu'
        skt = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
        skt.bind((SERVER_IP, PORT))
        print(f'Usage : dig -p {PORT} @{SERVER_IP} q_type domain_name')
    except:
        print("### Error in creating socket ###")
    #print("return value of socket", skt)
    return skt

# this function is defined to process the dns query based on the input provided in parameters.
def process_dns_query(logger,query, deny_list, d, doh_server=None, doh=None):
    try:
        domain_name = str(query.q.qname)[:-1] # to get the domain name in the string by trailing the dot in the domain name.
        domain_type = query.q.qtype # defining the type of domain.
        qtype = qtype_map[domain_type] # to map the domain name in  human readable format
        #.get(domain_type, 'UNKNOWN')

        # to check if the domain name is there in the list or not
        if domain_name in deny_list:
            logger.info(f'{domain_name} {qtype} DENY')
            return DNSRecord(DNSHeader(id=query.header.id, qr=1, aa=1, ra=1, rcode=3), q=DNSQuestion(domain_name, qtype=query.q.qtype))
        else:
            # logger.info(f'{domain_name} {qtype} ALLOW')

            print(f"\n#{doh_server} {doh} {doh_server or doh} {doh_server and doh}#\n")

            if doh_server or doh:
                print("/n In doh_server or doh\n")
                # Use DoH for DNS forwarding
                req = DNS(rd=1, qd=DNSQR(qname=domain_name, qtype=domain_type))
                b = bytes(req)
                temp = ""
                if doh_server:
                    temp = doh_server
                else:
                    temp = "8.8.8.8"
                url = f'https://{temp}/dns-query?dns={base64.urlsafe_b64encode(b).rstrip(b"=").decode()}'
                headers = {'content-type': 'application/dns-message'}
                #print("headers", headers)
                response = requests.get(url, headers=headers)
                # print ("response", response)
                output = DNS(response.content)
                flags = [
                    output.qr,
                    output.rd,
                    output.ra,
                    output.ad,
                    output.aa,
                ] 
                response = DNSRecord(
                    DNSHeader(
                        id=query.header.id,
                        qr=flags[0],
                        rd=flags[1],
                        ra=flags[2],
                        ad=flags[3],
                        aa=flags[4],
                        rcode=output.rcode,
                    ),
                    q=DNSQuestion(domain_name, qtype=query.q.qtype),
                )
                for i in range(output[DNS].ancount):
                    response.add_answer(
                        *RR.fromZone(
                            str(
                                f"{domain_name} {output[DNSRR][i].ttl} IN {qtype} {output[DNSRR][i].rdata}"
                            )
                        )
                    )
                print(output)
            else:
                # DNS forwarding
                my_resolver = dns.resolver.Resolver()
                my_resolver.nameservers = [d]
                answer = my_resolver.resolve(domain_name, domain_type)
                response = DNSRecord(DNSHeader(id=query.header.id, qr=1, aa=1, ra=1, rcode=answer.response.rcode()), q=DNSQuestion(domain_name, qtype=query.q.qtype))
                for i in answer.response.answer:
                    response.add_answer(*RR.fromZone(str(i)))
            logger.info(f'{domain_name} {qtype} ALLOW')
    except:
        print("### Error in processing request ###")
        logger.info(f'{domain_name} {qtype} Network error')
        return DNSRecord(DNSHeader(id=query.header.id, qr=1, aa=1, ra=1, rcode=3), q=DNSQuestion(domain_name, qtype=query.q.qtype))
    #print(response)
    return response

 # main function
def main():
    parser = argparse.ArgumentParser(description='DNS FORWARDER')
    parser.add_argument("-d", metavar='DST_IP', type=str, help='Destination DNS server IP', required=False)
    parser.add_argument("-f", metavar='DENY_LIST_FILE', type=str, help='File containing domains to block', required=False)
    parser.add_argument("-l", metavar='LOG_FILE', default='logfile.log', type=str, help='Append-only log file', required=False)
    parser.add_argument("--doh", help='Use default upstream DoH server', action='store_true')
    parser.add_argument("--doh_server", metavar='DOH_SERVER', type=str, help='Use this upstream DoH server', required=False)
    args = parser.parse_args()

    '''
    with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as server_socket:
        server_socket.bind(('0.0.0.0', 53))

        while True:
            data, client_address = server_socket.recvfrom(512)
        
            if is_blocked_domain(data, deny_list):
            
                response = create_nxdomain_response(data)
                server_socket.sendto(response, client_address)
            else:
                
                resolved_data = resolve_dns(data, args.doh_server)
                server_socket.sendto(resolved_data, client_address)
            '''
    print(f"\n**{args.doh_server}**\n")

    logger = get_logger(args.l)
    if os.path.exists(args.f):
        with open(args.f) as f:
            deny_list = [line.rstrip() for line in f]
    else:
        print(f"The file '{args.f}' does not exist.")
        exit()
    

    skt = create_server()
    data = ''
    while True:
        # to receive the data from UDP socket
        data, client_address = skt.recvfrom(4096)
        # To parse the received data and expected  the query in binary form
        query = DNSRecord.parse(data)
        response = process_dns_query(logger,query, deny_list, args.d, args.doh_server if args.doh_server else None, args.doh if args.doh else None)
        # To send the query stored in response back to the client
        skt.sendto(response.pack(), client_address)

if __name__ == "__main__":
    main()